/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * call_custom_exp_wrapper_fixpt.c
 *
 * Code generation for function 'call_custom_exp_wrapper_fixpt'
 *
 */

/* Include files */
#include "mwmathutil.h"
#include "rt_nonfinite.h"
#include "call_custom_exp_fixpt_logger.h"
#include "call_custom_exp_wrapper_fixpt.h"
#include "call_custom_exp_wrapper_fixpt_hdl_mex_data.h"

/* Variable Definitions */
static emlrtRSInfo emlrtRSI = { 9,     /* lineNo */
  "call_custom_exp_wrapper_fixpt",     /* fcnName */
  "/home/sky/Documents/MATLAB/Low_density_parity_code/archive/codegen/call_custom_exp/fixpt/call_custom_exp_wrapper_fixpt.m"/* pathName */
};

static emlrtRSInfo b_emlrtRSI = { 10,  /* lineNo */
  "call_custom_exp_fixpt",             /* fcnName */
  "/home/sky/Documents/MATLAB/Low_density_parity_code/archive/codegen/call_custom_exp/fixpt/call_custom_exp_fixpt.m"/* pathName */
};

static emlrtRSInfo c_emlrtRSI = { 1,   /* lineNo */
  "call_custom_exp_fixpt",             /* fcnName */
  "/home/sky/Documents/MATLAB/Low_density_parity_code/archive/codegen/call_custom_exp/fixpt/call_custom_exp_fixpt.m"/* pathName */
};

static emlrtRSInfo d_emlrtRSI = { 5,   /* lineNo */
  "LogInputsAndOutputs.cpp:51",        /* fcnName */
  "src/LogInputsAndOutputs.cpp:51"     /* pathName */
};

/* Function Definitions */
real_T call_custom_exp_wrapper_fixpt(const emlrtStack *sp, real_T x)
{
  real_T d0;
  int16_T y_out;
  int16_T b_x;
  int32_T c_x;
  int32_T b_y_out;
  int32_T i0;
  int32_T i1;
  int32_T x_idx;
  int16_T idx_bot;
  int32_T b_x_idx;
  int32_T c_x_idx;
  int32_T i2;
  int64_T i3;
  int32_T d_x_idx;
  int32_T i4;
  int64_T i5;
  int64_T i6;
  int64_T i7;
  int64_T i8;
  emlrtStack st;
  emlrtStack b_st;
  emlrtStack c_st;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;

  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /*                                                                           % */
  /*            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % */
  /*                                                                           % */
  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  d0 = muDoubleScalarFloor(x * 512.0);
  if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
    d0 = 0.0;
  } else {
    d0 = muDoubleScalarRem(d0, 16384.0);
  }

  y_out = (int16_T)d0;
  if ((y_out & 8192) != 0) {
    b_x = (int16_T)(y_out | -8192);
  } else {
    b_x = (int16_T)(y_out & 8191);
  }

  st.site = &emlrtRSI;

  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /*                                                                           % */
  /*            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % */
  /*                                                                           % */
  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  b_st.site = &b_emlrtRSI;

  /*  */
  /*  Copyright 2019 The MathWorks, Inc. */
  /*  calculate replacement_custom_fnc via lookup table between extents x = fi([-10,10]), */
  /*  interpolation degree  = 1, number of points = 1024 */
  if ((b_x & 16384) != 0) {
    c_x = b_x | -16384;
  } else {
    c_x = b_x & 16383;
  }

  y_out = (int16_T)(c_x - -5120);
  if ((y_out & 16384) != 0) {
    b_y_out = y_out | -16384;
  } else {
    b_y_out = y_out & 16383;
  }

  i0 = b_y_out * 13094;
  if ((i0 & 536870912) != 0) {
    i1 = i0 | -536870912;
  } else {
    i1 = i0 & 536870911;
  }

  i0 = i1 >> 11;
  if ((i0 & 131072) != 0) {
    x_idx = i0 | -131072;
  } else {
    x_idx = i0 & 131071;
  }

  y_out = (int16_T)(x_idx >> 6);
  if ((y_out & 2048) != 0) {
    idx_bot = (int16_T)(y_out | -2048);
  } else {
    idx_bot = (int16_T)(y_out & 2047);
  }

  if ((x_idx & 262144) != 0) {
    b_x_idx = x_idx | -262144;
  } else {
    b_x_idx = x_idx & 262143;
  }

  i0 = b_x_idx + 64;
  if ((i0 & 262144) != 0) {
    i0 |= -262144;
  } else {
    i0 &= 262143;
  }

  if ((i0 & 131072) != 0) {
    x_idx = i0 | -131072;
  } else {
    x_idx = i0 & 131071;
  }

  if (idx_bot >= 1024) {
    idx_bot = 1023;
  } else {
    if (idx_bot <= 0) {
      idx_bot = 1;
    }
  }

  y_out = (int16_T)(idx_bot + 1);
  if ((x_idx & 262144) != 0) {
    c_x_idx = x_idx | -262144;
  } else {
    c_x_idx = x_idx & 262143;
  }

  i0 = c_x_idx - (idx_bot << 6);
  if ((i0 & 262144) != 0) {
    i2 = i0 | -262144;
  } else {
    i2 = i0 & 262143;
  }

  i3 = (int64_T)LUT[y_out - 1] * i2;
  if ((i3 & 4294967296L) != 0L) {
    i3 |= -4294967296L;
  } else {
    i3 &= 4294967295L;
  }

  if ((x_idx & 262144) != 0) {
    d_x_idx = x_idx | -262144;
  } else {
    d_x_idx = x_idx & 262143;
  }

  i0 = (y_out << 6) - d_x_idx;
  if ((i0 & 262144) != 0) {
    i4 = i0 | -262144;
  } else {
    i4 = i0 & 262143;
  }

  i5 = (int64_T)LUT[idx_bot - 1] * i4;
  if ((i5 & 4294967296L) != 0L) {
    i5 |= -4294967296L;
  } else {
    i5 &= 4294967295L;
  }

  if ((i3 & 8589934592L) != 0L) {
    i6 = i3 | -8589934592L;
  } else {
    i6 = i3 & 8589934591L;
  }

  if ((i5 & 8589934592L) != 0L) {
    i7 = i5 | -8589934592L;
  } else {
    i7 = i5 & 8589934591L;
  }

  i3 = i6 + i7;
  if ((i3 & 8589934592L) != 0L) {
    i8 = i3 | -8589934592L;
  } else {
    i8 = i3 & 8589934591L;
  }

  y_out = (int16_T)((int16_T)i8 << 4);
  if ((y_out & 8192) != 0) {
    y_out = (int16_T)(y_out | -8192);
  } else {
    y_out = (int16_T)(y_out & 8191);
  }

  b_st.site = &c_emlrtRSI;
  c_st.site = &d_emlrtRSI;
  b_call_custom_exp_fixpt_logger(&c_st, b_x, y_out);
  return (real_T)y_out * 0.001953125;
}

/* End of code generation (call_custom_exp_wrapper_fixpt.c) */
