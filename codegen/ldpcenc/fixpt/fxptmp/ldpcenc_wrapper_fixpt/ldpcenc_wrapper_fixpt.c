/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * ldpcenc_wrapper_fixpt.c
 *
 * Code generation for function 'ldpcenc_wrapper_fixpt'
 *
 */

/* Include files */
#include "mwmathutil.h"
#include "rt_nonfinite.h"
#include "ldpcenc_fixpt_logger.h"
#include "ldpcenc_wrapper_fixpt.h"

/* Variable Definitions */
static emlrtRSInfo emlrtRSI = { 9,     /* lineNo */
  "ldpcenc_wrapper_fixpt",             /* fcnName */
  "/home/sky/Documents/MATLAB/Low_density_parity_code/codegen/ldpcenc/fixpt/ldpcenc_wrapper_fixpt.m"/* pathName */
};

static emlrtRSInfo b_emlrtRSI = { 1,   /* lineNo */
  "ldpcenc_fixpt",                     /* fcnName */
  "/home/sky/Documents/MATLAB/Low_density_parity_code/codegen/ldpcenc/fixpt/ldpcenc_fixpt.m"/* pathName */
};

static emlrtRSInfo c_emlrtRSI = { 5,   /* lineNo */
  "LogInputsAndOutputs.cpp:51",        /* fcnName */
  "src/LogInputsAndOutputs.cpp:51"     /* pathName */
};

/* Function Definitions */
void ldpcenc_wrapper_fixpt(const emlrtStack *sp, const real_T m[4], real_T
  codedout[7])
{
  real_T d0;
  uint8_T m_in[4];
  int32_T b_m;
  int32_T c_tmp;
  uint8_T codedout_out[7];
  uint8_T c;
  static const int8_T b0[28] = { 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0,
    0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 };

  uint8_T z1[7];
  emlrtStack st;
  emlrtStack b_st;
  emlrtStack c_st;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;

  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /*                                                                           % */
  /*            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % */
  /*                                                                           % */
  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  d0 = muDoubleScalarFloor(m[0]);
  if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
    d0 = 0.0;
  } else {
    d0 = muDoubleScalarRem(d0, 2.0);
  }

  m_in[0] = (uint8_T)((uint8_T)(int8_T)d0 & 1);
  d0 = muDoubleScalarFloor(m[1]);
  if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
    d0 = 0.0;
  } else {
    d0 = muDoubleScalarRem(d0, 2.0);
  }

  m_in[1] = (uint8_T)((uint8_T)(int8_T)d0 & 1);
  d0 = muDoubleScalarFloor(m[2]);
  if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
    d0 = 0.0;
  } else {
    d0 = muDoubleScalarRem(d0, 2.0);
  }

  m_in[2] = (uint8_T)((uint8_T)(int8_T)d0 & 1);
  d0 = muDoubleScalarFloor(m[3]);
  if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
    d0 = 0.0;
  } else {
    d0 = muDoubleScalarRem(d0, 2.0);
  }

  m_in[3] = (uint8_T)((uint8_T)(int8_T)d0 & 1);
  st.site = &emlrtRSI;

  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /*                                                                           % */
  /*            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % */
  /*                                                                           % */
  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /*  file name:    ldpcenc.m */
  /*  description:  codedout = ldpcenc(m,G) performs ldpc encoding given the message block m and the generator matrix G. */
  /*                see 'ldpcsim.m' for an example. */
  /*                note that the function actually applies to binary block encoding in general. */
  /*     */
  /*                This code is modified for a 7,4 coding scheme */
  /*  */
  /*  algorithm:    c = m*G */
  /*  author:       y. jiang  */
  /*  modified:     Skylar T. */
  /*  date:         april 2019 */
  /*  revision:     1.1a */
  /* pre-allocating, hdl-coder doesn't like passing arrays, since vhdl doesn't */
  /* have any support for passing an array */
  /* might be able to replace this with a xor gate and a multiply, but will */
  /* leave for now */
  for (b_m = 0; b_m < 7; b_m++) {
    c_tmp = b_m << 2;
    c = (uint8_T)((uint8_T)((uint8_T)((uint8_T)((uint32_T)m_in[0] * b0[c_tmp]) +
      (uint32_T)m_in[1] * b0[1 + c_tmp]) + (uint32_T)m_in[2] * b0[2 + c_tmp]) +
                  (uint32_T)m_in[3] * b0[3 + c_tmp]);
    z1[b_m] = (uint8_T)((uint32_T)c - ((int32_T)((uint32_T)c >> 1) << 1));
    c = z1[b_m];
    if (z1[b_m] > 15) {
      c = 15U;
    }

    codedout_out[b_m] = (uint8_T)(c & 1);
  }

  b_st.site = &b_emlrtRSI;
  c_st.site = &c_emlrtRSI;
  b_ldpcenc_fixpt_logger(&c_st, m_in, codedout_out);
  for (b_m = 0; b_m < 7; b_m++) {
    codedout[b_m] = codedout_out[b_m];
  }
}

/* End of code generation (ldpcenc_wrapper_fixpt.c) */
