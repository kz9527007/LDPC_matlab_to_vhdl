/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * call_custom_exp_wrapper_fixpt.c
 *
 * Code generation for function 'call_custom_exp_wrapper_fixpt'
 *
 */

/* Include files */
#include "mwmathutil.h"
#include "rt_nonfinite.h"
#include "call_custom_exp_fixpt_logger.h"
#include "call_custom_exp_wrapper_fixpt.h"
#include "call_custom_exp_wrapper_fixpt_hdl_mex_data.h"

/* Variable Definitions */
static emlrtRSInfo emlrtRSI = { 9,     /* lineNo */
  "call_custom_exp_wrapper_fixpt",     /* fcnName */
  "/home/sky/Documents/MATLAB/Low_density_parity_code/codegen/call_custom_exp/fixpt/call_custom_exp_wrapper_fixpt.m"/* pathName */
};

static emlrtRSInfo b_emlrtRSI = { 10,  /* lineNo */
  "call_custom_exp_fixpt",             /* fcnName */
  "/home/sky/Documents/MATLAB/Low_density_parity_code/codegen/call_custom_exp/fixpt/call_custom_exp_fixpt.m"/* pathName */
};

static emlrtRSInfo c_emlrtRSI = { 1,   /* lineNo */
  "call_custom_exp_fixpt",             /* fcnName */
  "/home/sky/Documents/MATLAB/Low_density_parity_code/codegen/call_custom_exp/fixpt/call_custom_exp_fixpt.m"/* pathName */
};

static emlrtRSInfo d_emlrtRSI = { 5,   /* lineNo */
  "LogInputsAndOutputs.cpp:51",        /* fcnName */
  "src/LogInputsAndOutputs.cpp:51"     /* pathName */
};

/* Function Definitions */
real_T call_custom_exp_wrapper_fixpt(const emlrtStack *sp, real_T x)
{
  real_T d0;
  int16_T idx_top;
  int16_T b_x;
  int32_T c_x;
  int32_T b_idx_top;
  int32_T i0;
  int32_T i1;
  int16_T x_idx;
  int16_T idx_bot;
  int32_T b_x_idx;
  int32_T c_x_idx;
  int32_T i2;
  int32_T i3;
  int32_T i4;
  int32_T d_x_idx;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  uint16_T y_out;
  emlrtStack st;
  emlrtStack b_st;
  emlrtStack c_st;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;
  c_st.prev = &b_st;
  c_st.tls = b_st.tls;

  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /*                                                                           % */
  /*            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % */
  /*                                                                           % */
  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  d0 = muDoubleScalarFloor(x * 512.0);
  if (muDoubleScalarIsNaN(d0) || muDoubleScalarIsInf(d0)) {
    d0 = 0.0;
  } else {
    d0 = muDoubleScalarRem(d0, 16384.0);
  }

  idx_top = (int16_T)d0;
  if ((idx_top & 8192) != 0) {
    b_x = (int16_T)(idx_top | -8192);
  } else {
    b_x = (int16_T)(idx_top & 8191);
  }

  st.site = &emlrtRSI;

  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /*                                                                           % */
  /*            Generated by MATLAB 9.5 and Fixed-Point Designer 6.2           % */
  /*                                                                           % */
  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  b_st.site = &b_emlrtRSI;

  /*  */
  /*  Copyright 2019 The MathWorks, Inc. */
  /*  calculate replacement_custom_exp via lookup table between extents x = fi([-10,10]), */
  /*  interpolation degree  = 1, number of points = 1000 */
  if ((b_x & 16384) != 0) {
    c_x = b_x | -16384;
  } else {
    c_x = b_x & 16383;
  }

  idx_top = (int16_T)(c_x - -5120);
  if ((idx_top & 16384) != 0) {
    b_idx_top = idx_top | -16384;
  } else {
    b_idx_top = idx_top & 16383;
  }

  i0 = b_idx_top * 12787;
  if ((i0 & 536870912) != 0) {
    i1 = i0 | -536870912;
  } else {
    i1 = i0 & 536870911;
  }

  x_idx = (int16_T)(i1 >> 12);
  idx_top = (int16_T)(x_idx >> 5);
  if ((idx_top & 1024) != 0) {
    idx_bot = (int16_T)(idx_top | -1024);
  } else {
    idx_bot = (int16_T)(idx_top & 1023);
  }

  if ((x_idx & 65536) != 0) {
    b_x_idx = x_idx | -65536;
  } else {
    b_x_idx = x_idx & 65535;
  }

  i0 = b_x_idx + 32;
  if ((i0 & 65536) != 0) {
    x_idx = (int16_T)(i0 | -65536);
  } else {
    x_idx = (int16_T)(i0 & 65535);
  }

  if (idx_bot >= 1000) {
    idx_bot = 999;
  } else {
    if (idx_bot <= 0) {
      idx_bot = 1;
    }
  }

  idx_top = (int16_T)(idx_bot + 1);
  if ((idx_top & 1024) != 0) {
    idx_top = (int16_T)(idx_top | -1024);
  } else {
    idx_top = (int16_T)(idx_top & 1023);
  }

  if ((x_idx & 65536) != 0) {
    c_x_idx = x_idx | -65536;
  } else {
    c_x_idx = x_idx & 65535;
  }

  i0 = c_x_idx - (idx_bot << 5);
  if ((i0 & 65536) != 0) {
    i2 = i0 | -65536;
  } else {
    i2 = i0 & 65535;
  }

  i0 = LUT[idx_top - 1] * i2;
  i3 = idx_top << 5;
  if ((i3 & 65536) != 0) {
    i4 = i3 | -65536;
  } else {
    i4 = i3 & 65535;
  }

  if ((x_idx & 65536) != 0) {
    d_x_idx = x_idx | -65536;
  } else {
    d_x_idx = x_idx & 65535;
  }

  i3 = i4 - d_x_idx;
  if ((i3 & 65536) != 0) {
    i5 = i3 | -65536;
  } else {
    i5 = i3 & 65535;
  }

  i3 = LUT[idx_bot - 1] * i5;
  if ((i0 & 1073741824) != 0) {
    i6 = i0 | -1073741824;
  } else {
    i6 = i0 & 1073741823;
  }

  if ((i3 & 1073741824) != 0) {
    i7 = i3 | -1073741824;
  } else {
    i7 = i3 & 1073741823;
  }

  y_out = (uint16_T)((uint16_T)((i6 + i7) >> 5) & 16383);
  b_st.site = &c_emlrtRSI;
  c_st.site = &d_emlrtRSI;
  b_call_custom_exp_fixpt_logger(&c_st, b_x, y_out);
  return (real_T)y_out * 2.0;
}

/* End of code generation (call_custom_exp_wrapper_fixpt.c) */
